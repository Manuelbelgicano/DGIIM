% Autor: Manuel Gachs Ballegeer
% Github: https://github.com/Manuelbelgicano
% Licencia: GNU General Public License v3.0
% Versión: 0.1

\documentclass[11pt,twoside,titlepage,a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			   COLORINES				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
\definecolor{rojooscuro}{HTML}{8A0808}
\definecolor{burdeos}{HTML}{610B0B}
\definecolor{rojomorado}{HTML}{B40431}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			  MATEMÁTICAS				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath} % Matemáticas
\usepackage{amsfonts} % Letras caligráficas para matemáticas
\usepackage{mathtools} % Matemáticas extra
\usepackage{amsthm} % Teoremas
\usepackage{dirtree} % Árboles
% Eliminar '*' para añadir numeración a los lemas, teoremas...
\theoremstyle{definition}
\newtheorem*{defi}{Definición} % Comando para las definiciones
\newtheoremstyle{plain_rojo}{}{}{}{}{\color{rojooscuro}\bfseries}{:}{ }{}
\theoremstyle{plain_rojo}
\newtheorem*{lem}{Lema} % Comando para los lemas
\newtheorem*{teo}{Teorema} % Comando para los teoremas
\theoremstyle{remark}
\newtheorem*{cor}{Corolario} % Comando para los corolarios
\renewenvironment{proof}{{\bfseries\color{rojooscuro}Demostración:}}{\qed} % Cambiar el título de las demostraciones

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			   TIPOGRAFÍA				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[rm,light]{roboto}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				  CÓDIGO				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listingsutf8}
\lstset{
	inputencoding=utf8/latin1, % Codificación
	xleftmargin=1em, % Margen extra a la izquierda
	breaklines=true, % Romper líneas largas
	language=make, % Lenguaje del código
	frame=single, % Enmarcado
	numbers=none, % Números de línea
	numbersep=8pt, % Separación de los números de línea
	tabsize=4, % Tamaño de los tabs
	frame=leftline, % Posición del enmarcado
	framerule=2pt, % Grosor del enmarcado
	showstringspaces=false, % Mostrar los espacios en las cadenas de caracteres
	basicstyle=\ttfamily, % Estilo del código
	keywordstyle=\color{burdeos}, % Estilo de las palabras reservadas
	numberstyle=\normalfont, % Estilo de los números de línea
	rulecolor=\color{rojooscuro}, % Estilo del enmarcado
	commentstyle=\color{red}, % Estilo de los comentarios
	stringstyle=\color{rojomorado} % Estilo de las cadenas de caracteres
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				MÁRGENES				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[a4paper]{geometry}
\geometry{
	left=2.5cm, % Margen izquierdo
	right=2.5cm, % Margen derecho
	bottom=2.5cm % Margen inferior
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  			  LISTAS/TABLAS				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{enumitem} % Opciones de personalización de listas
\renewcommand{\arraystretch}{1.3} %Cambiar el tamaño entre líneas de una tabla

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		COMANDOS PERSONALIZADOS 		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\autores}{ % Autores del documento
	\begin{tabular}{l}
	Manuel Gachs Ballegeer
	\end{tabular}
}
\newcommand{\institucion}{ % Insitución
	Makefiles
}
\newcommand{\infoextra}{ % Año o cualquier otra información para el título
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		ENCABEZADO/PIE DE PAGINA		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\setlength{\headheight}{14pt}
\pagestyle{fancy}
\fancyhf{}
% Para que aparezca el título de la sección y no el número 
\renewcommand{\sectionmark}[1]{%
\markboth{#1}{}}
% Encabezado
\fancyhead[LE,RO]{\color{burdeos}{\leftmark}} % A la izquierda en pares, derecha en impares
\fancyhead[RE,LO]{\color{burdeos}{\institucion}} % A la derecha en pares, izquierda en impares
% Pie de página
\fancyfoot[LE,RO]{\Large\textbf{\thepage}} % A la izquierda en pares, derecha en impares
\renewcommand{\headrulewidth}{0.5pt} % Grosor de la línea

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			   	TÍTULOS					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{titlesec}
\titleformat{\section} % Estilo de las secciones
{\color{rojooscuro}\Huge\bfseries}
{\color{rojooscuro}\thesection}{1em}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		   	  MISCELÁNEO				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pagecolor} % Colorear las portadas
\renewcommand{\contentsname}{Índice} % Cambiar el título del índice
\setlength\parindent{0pt} % Tamaño de la sangría
\usepackage{graphicx} % Imágenes
\usepackage{blindtext} % Texto de relleno (Se puede eliminar)

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 PORTADA 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\newpagecolor{rojooscuro} % Color de la portada
	\parbox[t]{\textwidth}{
		\raggedright
		\color{white}{\LARGE{\textbf{}}} \\
		\textit{\infoextra}
	}
	\vfill
	\parbox[c]{\textwidth}{
		\color{white}{
			\fontsize{70pt}{70pt}{\textbf{Makefiles}} \\
			\bigskip \\
			\fontsize{30pt}{30pt}{\emph{Una pequeña guía}}
		}
	}
	\vfill
	\parbox[t]{\textwidth}{
		\raggedright
		\color{white}{\Large{\autores}} \\
	}
\end{titlepage}
\restorepagecolor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 ÍNDICE 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 DOCUMENTO 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			  INTRODUCCIÓN				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}

Un archivo del tipo \textbf{makefile} es un archivo que hace uso de la
utilidad \texttt{make}. Esta utilidad determina qué partes de un programa
deben de compilarse, y les manda comandos para hacerlo. En esencia, un
makefile sirve para autocompilar un proyecto en lugar de hacerlo manualmente.
Esto tiene mucho interés y utilidad cuando trabajamos con proyectos de tamaño
considerable que están formados por muchos archivos, en los que la compilación
manual de los archivos es inviable. Estos apuntes pretenden dar unas cuantas
nociones acerca de cómo funciona la orden \texttt{make} y cómo hacer makefiles
que puedan servir para proyectos personales.
\\

Para poder hacer uso de \texttt{make}, en primer lugar debe crearse un 
archivo del tipo makefile. Para ello basta con crear uno con nombre 
"makefile" o "Makefile". Ambos nombres son completamente válidos, aunque el 
segundo es más recomendable\footnote{El manual de la GNU lo recomienda, ya 
que al estar nombrado de esta manera, suele aparecer cerca del 
inicio en los listados de directorios, junto otros arhcivos importantes como 
README}.
\\

Es posible también nombrar un archivo makefile con otro nombre, pero debemos 
especificárselo a \texttt{make} en la llamada con uno de los siguientes 
formatos:
\bigskip
\begin{lstlisting}
make -f <archivo>
make --file=<archivo>
make --makefile=<archivo>
\end{lstlisting}
\bigskip
Los ejemplos de makefiles y programas de estos apuntes suponen que el 
proyecto está escrito en C++. Sin embargo, los makefiles sirven para muchos 
más lenguajes de programación, además del presentado en estos apuntes. Para 
información más a fondo sobre makefiles que no aparezca en estos apuntes es 
recomendable consultar el manual de la GNU de la orden \texttt{make}.

\subsection{Contenido de un makefile}

Los makefiles no dejan de ser una especie de scripts, por lo que son una
colección de órdenes que deben realizarse. Esencialmente, están compuestos de 
estos cuatro tipos de oraciones:
\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item \textbf{\textcolor{rojooscuro}{Reglas:}} Contienen las
	instrucciones que queremos que realice la orden \texttt{make}.
	\begin{description}[align=left,font={\color{burdeos}\bfseries}]
		\item [Relgas explícitas] Reglas descritas por el autor del makefile.
		\item [Reglas implícitas] Reglas automáticas que puede realizar 
		\texttt{make}.
	\end{description}
	\item \textbf{\textcolor{rojooscuro}{Definiciones de variables:}} Alias
	creados por el autor del makefile con el propósito de hacer el archivo
	más legible y fácil de modificar o ampliar.
	\item \textbf{\textcolor{rojooscuro}{Directivas y funciones:}} 
	Expresiones o palabras que se utilizan para simplificar las reglas de un
	makefile.
	\item \textbf{\textcolor{rojooscuro}{Comentarios:}} Anotaciones que 
	aportan claridad al makefile. Para escribir un comentario, simplemente 
	tiene que comenzar por el caracter "\#".
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 REGLAS 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Reglas}

Para hacerse una idea del concepto de regla, veamos un ejemplo. Imaginemos que
tenemos un programa que consta de un archivo con nombre \texttt{goblin.cpp}, y
ese archivo utiliza la cabecera \texttt{goblin.h}. Para obtener el archivo 
objeto (\texttt{goblin.o}), tendríamos que escribir la siguiente orden en la terminal:
\bigskip
\begin{lstlisting}
g++ -c -g goblin.cpp
\end{lstlisting}
\bigskip
En un makefile, esta orden de la terminal se traduciría en la siguiente regla:
\bigskip
\begin{lstlisting}
goblin.o: goblin.cpp goblin.h
	g++ -c -g goblin.cpp
\end{lstlisting}
\bigskip
Aunque la segunda línea sea idéntica a la que escribiríamos en la terminal,
podemos ver que para compilar el archivo usando un makefile hace falta más
información. Esta regla nos dice dos cosas:

\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item Cuándo se ejecutará. Esta información nos la proporciona la primera
	línea. ¿A qué nos referimos cuando decimos que nos dice cuándo se va a 
	ejecutar? Bien, solamente realizará la orden de compilación cuando:
	\begin{itemize}[font={\color{rojooscuro}\bfseries}]
		\item El archivo \texttt{goblin.o} no exista.
		\item El archivo \texttt{goblin.o} exista, pero los archivos
		\texttt{goblin.cpp} y/o \texttt{goblin.h} hayan sido modificados con
		posterioridad a la compilación anterior.
	\end{itemize}
	\item Cómo se obtiene el archivo \texttt{goblin.o}, información que nos
	proporciona la segunda línea, y que simplemente es una copia de lo que
	escribiríamos si fueramos a compilar manualmente el archivo.
\end{enumerate}

Una vez visto este ejemplo, veremos cómo podemos escribir estas reglas y un
pequeño ejemplo funcional de un makefile.

\subsection{Sintaxis de una regla}

\subsubsection{Sintaxis general}

Una regla en un makefile tiene tres componentes diferenciables:

\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item \textcolor{rojooscuro}{\textbf{Objetivos} (normalmente uno)
	\textbf{:}} Es el archivo que se quiere obtener con la regla o el nombre 
	de la orden que queremos realizar.
	\item \textcolor{rojooscuro}{\textbf{Pre-requisitos o dependencias:}} Son 
	los archivos y reglas que son necesarios con anterioridad para ejecutar 
	la orden.
	\item \textcolor{rojooscuro}{\textbf{Recetas:}} Son las acciones u órdenes
	que debe realizar \texttt{make} secuencialmente para obtener el objetivo. 
	Normalmente concuerdan con sentencias que escribimos en la terminal.
\end{enumerate}
\newpage
Una regla suele verse así:
\bigskip
\begin{lstlisting}
objetivos: pre-requisitos
	receta
	...
\end{lstlisting}
\bigskip
O, alternativamente, de esta manera:
\bigskip
\begin{lstlisting}
objetivos: pre-requisitos; receta
	receta
	...
\end{lstlisting}
\bigskip
Es \textbf{muy importante} seguir al pie de la letra esta sintaxis, puesto
que \texttt{make} no identificará una línea como una receta si no comienza 
por un tab\footnote{No es válido una sucesión de espacios}, y tampoco sabrá 
interpretar la regla si el objetivo no está separado de las dependencias por 
el caracter ":". Además, esta sintaxis tiene las siguientes consecuencias:

\begin{itemize}[font={\color{rojooscuro}\bfseries}]
	\item Una línea en blanco que comienza por una tab no es una línea en 
	blanco, sino una receta vacía.
	\item Un comentario en una receta no actúa como un comentario de un 
	makefile, sino que será pasado al shell literalmente, por lo que depende 
	del shell si es tratado como comentario o no.
	\item La definición de una variable dentro del "contexto de una
	receta" (dentro de una regla e indentado con un tab), será tratado como 
	parte de una receta, no como una variable del makefile, y pasado al shell.
	\item Una expresión condicional dentro del contexto de una receta será 
	considerado parte de una receta y pasado al shell. 
\end{itemize}

\subsubsection{Sintaxis específica}

Volvamos al ejemplo del principio. En la práctica, los programa son más grandes y no suelen tener todos los archivos en un solo directorio. Imaginemos ahora que tenemos el siguiente árbol de directorios:

\dirtree{%
.1 /.
.2 doc.
.3 adventure.doxy.
.2 include.
.3 goblin.h.
.3 underground.h.
.2 Makefile.
.2 obj.
.2 src.
.3 dungeon.cpp.
.3 goblin.cpp.
.3 main.cpp.
}

Imaginemos que en el archivo Makefile se encuentra la regla descrita anteriormente para construir ``goblin.o``. Si hacemos la orden ``make`` saltará el siguiente error:

```bash
make: *** No rule to make target 'goblin.h', needed by 'goblin.o'.  Stop.
```

¿Cuál es la razón de este error? ¿No era ``goblin.h`` una dependencia y no un objetivo? Esto ocurre porque ``make`` busca archivos solamente en el directorio de trabajo actual. Al no encontrar la cabecera, interpreta que se trata del objetivo de una regla. ¿Cómo arreglar esto? Primeramente, debemos escribir la ruta completa del archivo de cabecera. Después, debemos especificar donde se encuentra ese archivo en la receta. Existen varias maneras de hacer esto: a través de la directiva ``vpath``, la variable ``VPATH`` y el uso de la opción ``-I`` o ``--include-dir`` en la regla. Las dos primeras opciones serán explicadas más adelante.

Esta opción de compilación busca posibles dependencias en  ``[directorio]``. En caso de no especificar ningún directorio, ``make`` busca en los siguientes directorios (si existen) en este orden: ``/usr/local/include``, ``usr/gnu/include``, ``/usr/local/include`` y ``/usr/include``. Otra opción interesante del compilador es ``-o <nombre>``. Esta opción permite modificar el nombre de la salida de la compilación, cambiándolo por ``nombre``. Además, suele ser interesante usar los siguientes flags: ``-Wall`` y ``-g``. El primero hace que el compilador nos muestre todos los warnings, mientras que el segundo especifica al compilador que el archivo resultante pueda ser debuggeado.






















\end{document}