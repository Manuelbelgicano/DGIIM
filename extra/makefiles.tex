% Autor: Manuel Gachs Ballegeer
% Github: https://github.com/Manuelbelgicano
% Licencia: GNU General Public License v3.0
% Versión: 0.1

\documentclass[11pt,twoside,titlepage,a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			   COLORINES				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
\definecolor{rojooscuro}{HTML}{8A0808}
\definecolor{burdeos}{HTML}{610B0B}
\definecolor{rojomorado}{HTML}{B40431}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			  MATEMÁTICAS				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath} % Matemáticas
\usepackage{amsfonts} % Letras caligráficas para matemáticas
\usepackage{mathtools} % Matemáticas extra
\usepackage{amsthm} % Teoremas
\usepackage{dirtree} % Árboles
% Eliminar '*' para añadir numeración a los lemas, teoremas...
\theoremstyle{definition}
\newtheorem*{defi}{Definición} % Comando para las definiciones
\newtheoremstyle{plain_rojo}{}{}{}{}{\color{rojooscuro}\bfseries}{:}{ }{}
\theoremstyle{plain_rojo}
\newtheorem*{lem}{Lema} % Comando para los lemas
\newtheorem*{teo}{Teorema} % Comando para los teoremas
\theoremstyle{remark}
\newtheorem*{cor}{Corolario} % Comando para los corolarios
\renewenvironment{proof}{{\bfseries\color{rojooscuro}Demostración:}}{\qed} % Cambiar el título de las demostraciones

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			   TIPOGRAFÍA				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[rm,light]{roboto}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				  CÓDIGO				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listingsutf8}
\lstset{
	inputencoding=utf8/latin1, % Codificación
	xleftmargin=1em, % Margen extra a la izquierda
	breaklines=true, % Romper líneas largas
	language=make, % Lenguaje del código
	frame=single, % Enmarcado
	numbers=none, % Números de línea
	numbersep=8pt, % Separación de los números de línea
	tabsize=4, % Tamaño de los tabs
	frame=leftline, % Posición del enmarcado
	framerule=2pt, % Grosor del enmarcado
	showstringspaces=false, % Mostrar los espacios en las cadenas de caracteres
	basicstyle=\ttfamily, % Estilo del código
	keywordstyle=\color{burdeos}, % Estilo de las palabras reservadas
	numberstyle=\normalfont, % Estilo de los números de línea
	rulecolor=\color{rojooscuro}, % Estilo del enmarcado
	commentstyle=\color{red}, % Estilo de los comentarios
	stringstyle=\color{rojomorado} % Estilo de las cadenas de caracteres
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				MÁRGENES				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[a4paper]{geometry}
\geometry{
	left=2.5cm, % Margen izquierdo
	right=2.5cm, % Margen derecho
	bottom=2.5cm % Margen inferior
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  			  LISTAS/TABLAS				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{enumitem} % Opciones de personalización de listas
\renewcommand{\arraystretch}{1.3} %Cambiar el tamaño entre líneas de una tabla

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		COMANDOS PERSONALIZADOS 		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\autores}{ % Autores del documento
	\begin{tabular}{l}
	Manuel Gachs Ballegeer
	\end{tabular}
}
\newcommand{\institucion}{ % Insitución
	Makefiles
}
\newcommand{\infoextra}{ % Año o cualquier otra información para el título
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		ENCABEZADO/PIE DE PAGINA		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\setlength{\headheight}{14pt}
\pagestyle{fancy}
\fancyhf{}
% Para que aparezca el título de la sección y no el número 
\renewcommand{\sectionmark}[1]{%
\markboth{#1}{}}
% Encabezado
\fancyhead[LE,RO]{\color{burdeos}{\leftmark}} % A la izquierda en pares, derecha en impares
\fancyhead[RE,LO]{\color{burdeos}{\institucion}} % A la derecha en pares, izquierda en impares
% Pie de página
\fancyfoot[LE,RO]{\Large\textbf{\thepage}} % A la izquierda en pares, derecha en impares
\renewcommand{\headrulewidth}{0.5pt} % Grosor de la línea

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			   	TÍTULOS					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{titlesec}
\titleformat{\section} % Estilo de las secciones
{\color{rojooscuro}\Huge\bfseries}
{\color{rojooscuro}\thesection}{1em}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		   	  MISCELÁNEO				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pagecolor} % Colorear las portadas
\renewcommand{\contentsname}{Índice} % Cambiar el título del índice
\setlength\parindent{0pt} % Tamaño de la sangría
\usepackage{graphicx} % Imágenes
\usepackage{blindtext} % Texto de relleno (Se puede eliminar)

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 PORTADA 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\newpagecolor{rojooscuro} % Color de la portada
	\parbox[t]{\textwidth}{
		\raggedright
		\color{white}{\LARGE{\textbf{}}} \\
		\textit{\infoextra}
	}
	\vfill
	\parbox[c]{\textwidth}{
		\color{white}{
			\fontsize{70pt}{70pt}{\textbf{Makefiles}} \\
			\bigskip \\
			\fontsize{30pt}{30pt}{\emph{Una pequeña guía}}
		}
	}
	\vfill
	\parbox[t]{\textwidth}{
		\raggedright
		\color{white}{\Large{\autores}} \\
	}
\end{titlepage}
\restorepagecolor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 ÍNDICE 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 DOCUMENTO 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			  INTRODUCCIÓN				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}

Un archivo del tipo \textbf{makefile} es un archivo que hace uso de la
utilidad \texttt{make}. Esta utilidad determina qué partes de un programa
deben de compilarse, y les manda comandos para hacerlo. En esencia, un
makefile sirve para autocompilar un proyecto en lugar de hacerlo manualmente.
Esto tiene mucho interés y utilidad cuando trabajamos con proyectos de tamaño
considerable que están formados por muchos archivos, en los que la compilación
manual de los archivos es inviable. Estos apuntes pretenden dar unas cuantas
nociones acerca de cómo funciona la orden \texttt{make} y cómo hacer makefiles
que puedan servir para proyectos personales.
\\

Para poder hacer uso de \texttt{make}, en primer lugar debe crearse un 
archivo del tipo makefile. Para ello basta con crear uno con nombre 
"makefile" o "Makefile". Ambos nombres son completamente válidos, aunque el 
segundo es más recomendable\footnote{El manual de la GNU lo recomienda, ya 
que al estar nombrado de esta manera, suele aparecer cerca del 
inicio en los listados de directorios, junto otros arhcivos importantes como 
README}.
\\

Es posible también nombrar un archivo makefile con otro nombre, pero debemos 
especificárselo a \texttt{make} en la llamada con uno de los siguientes 
formatos:
\bigskip
\begin{lstlisting}
make -f <archivo>
make --file=<archivo>
make --makefile=<archivo>
\end{lstlisting}
\bigskip
Los ejemplos de makefiles y programas de estos apuntes suponen que el 
proyecto está escrito en C++. Sin embargo, los makefiles sirven para muchos 
más lenguajes de programación, además del presentado en estos apuntes. Para 
información más a fondo sobre makefiles que no aparezca en estos apuntes es 
recomendable consultar el manual de la GNU de la orden \texttt{make}.

\subsection{Contenido de un makefile}

Los makefiles no dejan de ser una especie de scripts, por lo que son una
colección de órdenes que deben realizarse. Esencialmente, están compuestos de 
estos cuatro tipos de oraciones:
\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item \textbf{\textcolor{rojooscuro}{Reglas:}} Contienen las
	instrucciones que queremos que realice la orden \texttt{make}.
	\begin{description}[align=left,font={\color{burdeos}\bfseries}]
		\item [Relgas explícitas] Reglas descritas por el autor del makefile.
		\item [Reglas implícitas] Reglas automáticas que puede realizar 
		\texttt{make}.
	\end{description}
	\item \textbf{\textcolor{rojooscuro}{Definiciones de variables:}} Alias
	creados por el autor del makefile con el propósito de hacer el archivo
	más legible y fácil de modificar o ampliar.
	\item \textbf{\textcolor{rojooscuro}{Directivas y funciones:}} 
	Expresiones o palabras que se utilizan para simplificar las reglas de un
	makefile.
	\item \textbf{\textcolor{rojooscuro}{Comentarios:}} Anotaciones que 
	aportan claridad al makefile. Para escribir un comentario, simplemente 
	tiene que comenzar por el caracter "\#".
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 REGLAS 				%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Reglas}

Para hacerse una idea del concepto de regla, veamos un ejemplo. Imaginemos que
tenemos un programa que consta de un archivo con nombre \texttt{goblin.cpp}, y
ese archivo utiliza la cabecera \texttt{goblin.h}. Para obtener el archivo 
objeto (\texttt{goblin.o}), tendríamos que escribir la siguiente orden en la terminal:
\bigskip
\begin{lstlisting}
g++ -c -g goblin.cpp
\end{lstlisting}
\bigskip
En un makefile, esta orden de la terminal se traduciría en la siguiente regla:
\bigskip\
\begin{lstlisting}
goblin.o: goblin.cpp goblin.h
	g++ -c -g goblin.cpp
\end{lstlisting}
\bigskip
Aunque la segunda línea sea idéntica a la que escribiríamos en la terminal,
podemos ver que para compilar el archivo usando un makefile hace falta más
información. Esta regla nos dice dos cosas:

\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item Cuándo se ejecutará. Esta información nos la proporciona la primera
	línea. ¿A qué nos referimos cuando decimos que nos dice cuándo se va a 
	ejecutar? Bien, solamente realizará la orden de compilación cuando:
	\begin{itemize}[font={\color{rojooscuro}\bfseries}]
		\item El archivo \texttt{goblin.o} no exista.
		\item El archivo \texttt{goblin.o} exista, pero los archivos
		\texttt{goblin.cpp} y/o \texttt{goblin.h} hayan sido modificados con
		posterioridad a la compilación anterior.
	\end{itemize}
	\item Cómo se obtiene el archivo \texttt{goblin.o}, información que nos
	proporciona la segunda línea, y que simplemente es una copia de lo que
	escribiríamos si fueramos a compilar manualmente el archivo.
\end{enumerate}

Una vez visto este ejemplo, veremos cómo podemos escribir estas reglas y un
pequeño ejemplo funcional de un makefile.

\subsection{Sintaxis de una regla}

\subsubsection{Sintaxis general}

Una regla en un makefile tiene tres componentes diferenciables:

\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item \textcolor{rojooscuro}{\textbf{Objetivos} (normalmente uno)
	\textbf{:}} Es el archivo que se quiere obtener con la regla o el nombre 
	de la orden que queremos realizar.
	\item \textcolor{rojooscuro}{\textbf{Pre-requisitos o dependencias:}} Son 
	los archivos y reglas que son necesarios con anterioridad para ejecutar 
	la orden.
	\item \textcolor{rojooscuro}{\textbf{Recetas:}} Son las acciones u órdenes
	que debe realizar \texttt{make} secuencialmente para obtener el objetivo. 
	Normalmente concuerdan con sentencias que escribimos en la terminal.
\end{enumerate}
\newpage
Una regla suele verse así:
\bigskip
\begin{lstlisting}
objetivos: pre-requisitos
	receta
	...
\end{lstlisting}
\bigskip
O, alternativamente, de esta manera:
\bigskip
\begin{lstlisting}
objetivos: pre-requisitos; receta
	receta
	...
\end{lstlisting}
\bigskip
Es \textbf{muy importante} seguir al pie de la letra esta sintaxis, puesto
que \texttt{make} no identificará una línea como una receta si no comienza 
por un tab\footnote{No es válido una sucesión de espacios}, y tampoco sabrá 
interpretar la regla si el objetivo no está separado de las dependencias por 
el caracter ":". Además, esta sintaxis tiene las siguientes consecuencias:

\begin{itemize}[font={\color{rojooscuro}\bfseries}]
	\item Una línea en blanco que comienza por una tab no es una línea en 
	blanco, sino una receta vacía.
	\item Un comentario en una receta no actúa como un comentario de un 
	makefile, sino que será pasado al shell literalmente, por lo que depende 
	del shell si es tratado como comentario o no.
	\item La definición de una variable dentro del "contexto de una
	receta" (dentro de una regla e indentado con un tab), será tratado como 
	parte de una receta, no como una variable del makefile, y pasado al shell.
	\item Una expresión condicional dentro del contexto de una receta será 
	considerado parte de una receta y pasado al shell. 
\end{itemize}

\subsubsection{Sintaxis específica}

Volvamos al ejemplo del principio. En la práctica, los programa son más grandes y no suelen tener todos los archivos en un solo directorio. Imaginemos ahora que tenemos el siguiente árbol de directorios:

\dirtree{%
.1 /.
.2 doc.
.3 adventure.doxy.
.2 include.
.3 goblin.h.
.3 underground.h.
.2 Makefile.
.2 obj.
.2 src.
.3 dungeon.cpp.
.3 goblin.cpp.
.3 main.cpp.
}

Imaginemos que en el archivo Makefile se encuentra la regla descrita 
anteriormente para construir \texttt{goblin.o}. Si hacemos la orden 
\texttt{make} saltará el siguiente error:
\bigskip
\begin{lstlisting}
make: *** No rule to make target 'goblin.h', needed by 'goblin.o'.  Stop.
\end{lstlisting}
\bigskip
¿Cuál es la razón de este error? ¿No era \texttt{goblin.h} una dependencia y
no un objetivo? El error es consecuencia de la limitación de la orden 
\texttt{make}, puesto que únicamente busca archivos en el directorio de
trabajo actual. Al no encontrar la cabecera, interpreta que se trata del 
objetivo de una regla. Para eliminar el problema, tenemos que hacer dos cosas:
Primero, debemos escribir la ruta completa del archivo de cabecera. Después, 
debemos especificar donde se encuentra ese archivo en la receta. Existen 
varias maneras de especificarlo: a través de la directiva \texttt{vpath}, la 
variable \texttt{VPATH} y el uso de la opción \texttt{-I} o 
\texttt{--include-dir} en la receta. Tanto la variable como la directiva se 
especificarán más adelante.
\\

En cuanto a las opciones de compilación en las recetas, éstas buscan posibles 
dependencias en el directorio dado como argumento. En caso de no especificar 
ningún directorio, \texttt{make} busca en los siguientes directorios (si 
existen) en este orden: 
\begin{enumerate}[noitemsep,font={\color{rojooscuro}\bfseries}]
	\item \texttt{/usr/local/include}
	\item \texttt{/usr/gnu/include}
	\item \texttt{/usr/include}
\end{enumerate}
Esta es la razón por la cual no es necesario cuando utilizamos cabeceras del 
estándar de C++. Otra opción interesante del compilador es 
\texttt{-o <nombre>}. Esta opción permite modificar el nombre de la salida de 
la compilación, cambiándolo por \texttt{nombre}. Además, suele ser 
interesante usar los siguientes flags: \texttt{-Wall} y \texttt{-g}. El 
primero hace que el compilador nos muestre todos los warnings, mientras que 
el segundo especifica al compilador que el archivo resultante pueda ser 
debuggeado.
\\

En resumen, un archivo makefile válido para el programa de ejemplo sería el
siguientes:

\begin{lstlisting}
all: adventure;

adventure: obj/dungeon.o obj/goblin.o obj/main.o
  g++ -Wall -g -o adventure obj/dungeon.o obj/goblin.o obj/main.o

obj/main.o: src/main.cpp include/dungeon.h
  g++ -Wall -g -I./include -c src/main.cpp -o obj/main.o

obj/dungeon.o: src/dungeon.cpp include/dungeon.h
  g++ -Wall -g -I./include -c src/dungeon.cpp -o obj/dungeon.o
  
obj/goblin.o: src/goblin.cpp include/goblin.h
  g++ -Wall -g -I./include -c src/goblin.cpp -o obj/goblin.o
\end{lstlisting}
\bigskip
Este ejemplo, aunque funcional, no es muy práctico, puesto que si se realiza 
un cambio en el nombre de una carpeta o de un archivo debe buscarse
manualmente todas sus instancias en las reglas y escribir el nuevo nombre. Es
por ello que se suelen usar variables para nombrar la mayoría de elementos de
un makefile.
\newpage
\subsection{Reglas especiales}

No todas las reglas tienen como objetivos archivos, o sus recetas son 
simplemente compilar, o tienen pre-requisitos. Como puede observarse, en el 
ejemplo anterior existe una regla llamada \texttt{all}, que no es un archivo
y no tiene recetas. Veamos qué son este tipo de reglas y cómo las podemos
utilizar.

\subsubsection{Reglas cuyo objetivo no es un archivo}

En muchas ocasiones es interesante no tener que realizar acciones 
manualmente, como eliminar archivos objeto, actualizar los archivos de la 
documentación, etc. Escribiendo en la terminal \texttt{make <orden>} podemos 
ejecutar la orden específica del makefile. He aquí una lista de los nombres 
para los objetivos del tipo de reglas de este tipo más usuales para el nivel
de esta guía:

\begin{itemize}[font={\color{rojooscuro}\bfseries}]
	\item \textcolor{rojooscuro}{\texttt{all}:} Esta regla es muy importante, 
	de hecho es casi obligada si se quiere estructurar el makefile de forma 
	flexible. Cuando usamos la orden \texttt{make}, siempre se ejecuta la 
	primera regla que aparezca en el makefile. En el caso de que tenga 
	\texttt{all},será esta la que se ejecute primero. Suele ser interesante 
	que sus pre-requisitos sean el archivo ejecutable del programa. Ejecutar 
	\texttt{make all} es equivalente a ejecutar \texttt{make}.
	\item \textcolor{rojooscuro}{\texttt{clean <name>}:} Se suele denominar 
	con ese nombre a las reglas que tienen como objetivo eliminar los 
	archivos \texttt{nombre}. Normalmente estos archivos suelen ser los 
	objeto, el ejecutable y los archivos de documentación. El contenido de este tipo de reglas suele ser una colección de órdenes del shell de borrado de archivos, como \texttt{rm}. No suele tener pre-requisitos.
	\item \textcolor{rojooscuro}{\texttt{documentation}:} Sirve para crear la 
	documentación del programa (como por ejemplo doxygen). El título de la 
	regla puede cambiarse por el nombre del programa de documentación. El 
	objetivo de la regla dependerá del programa de documentación de proyectos
	que se use en cada caso. No suele tener pre-requisitos.
	\item \textcolor{rojooscuro}{\texttt{zip}, \texttt{tar}...:} Estas reglas 
	se utilizan para comprimir el proyecto para su posterior distribución. De 
	tener pre-requisitos, suele ser la regla \texttt{clean}, para eliminar 
	los archivos innecesarios para la distribución del programa.
	\item \textcolor{rojooscuro}{\texttt{help}:} Se utiliza en el caso de que 
	se quiera mostrar un mensaje de ayuda sobre los posibles usos del
	makefile.
	\item \textcolor{rojooscuro}{\texttt{author}:} Esta regla se utiliza para
	mostrar iformación sobre el autor del makefile o del proyecto.
\end{itemize}

\subsubsection{Reglas sin receta}

Las reglas sin receta consisten en reglas que no hacen nada ellas mismas. La 
sintaxis preferente para este tipo de reglas es la que utiliza los puntos y
coma, puesto que queda más claro que se trata de una regla vacía. Estas 
reglas se utilizan para evitar las reglas ímplicitas o para evitar errores 
para objetivos que se crean como efecto secundario de otras recetas: si el 
objetivo no existe, este tipo de reglas aseguran que \texttt{make} no dé
errores al no saber cómo construir el objetivo, y asumirá que está
desactualizado. Esta última utilidad puede resultar muy interesante si 
queremos cerciorarnos de que siempre se ejecute una regla, puesto que podemos
poner una vacía como pre-requisito.

\subsubsection{Reglas con múltiples objetivos}

Escribir una regla con más de un objetivo es equivalente a escribir múltiples 
reglas idénticas en las que varía el objetivo. Es importante también notar 
que \textbf{pueden existir varias reglas con los mismos objetivos}, siempre 
teniendo en cuenta que en el caso de que más de una de ellas contenga 
recetas, \texttt{make} elegirá las recetas de la \textbf{última regla} que se 
haya definido. Las reglas con múltiples objetivos son útiles en dos casos:

\begin{enumerate}[font={\color{rojooscuro}\bfseries}]
	\item Varios objetivos comparten pre-requisitos. El poner una regla sin
	receta con varios objetivos de esta manera nos ahorra tener que escribir 
	ese pre-requisito en cada una de las reglas que lo necesiten. Un ejemplo
	sería el siguiente:
\begin{lstlisting}
obj/main.o obj/dungeon.o: include/dungeon.h
\end{lstlisting}
	Esto es equivalente a escribir el pre-requisito \texttt{include/dungeon.h}
	en las reglas que construyen \texttt{obj/dungeon.o} y \texttt{obj/main.o}.
	\item Recetas similares para todos los objetivos. Para poder utilizar
	este tipo de reglas es necesario conocer las variables automáticas, como
	\texttt{\$@}, que ser usada para sustituir un objetivo concreto. El uso 
	de este tipo de reglas lo explicaremos más adelante, cuando hablemos de 
	las variables en los makefiles y sus usos.
\end{enumerate}

\subsubsection{Reglas con pre-requisitos sólo-orden}

Llegados a este punto ya podemos hacer una distinción entre los 
pre-requisitos: Los normales y los de sólo orden\footnote{Esta es la 
traducción literal del término en inglés, es posible que en castellano tenga 
otro nombre.}. Normalmente, las reglas no comprueban la existencia de las 
dependencias antes de intentar ejecutar sus recetas. Sin embargo, los pre-
requisitos de sólo-orden cambian este comportamiento, puesto que fuerzan la 
comprobación con anterioridad. En caso de existir pre-requisitos de ambos 
tipos, tienen preferencia los de sólo-orden, esto es, son los primeros en 
comprobarse. No existe un orden de preferencia entre los pre-requisitos 
sólo-orden Es por ello que se pueden utilizar también, por ejemplo, para crear un 
directorio necesario para el objetivo antes de que se ejecuten las recetas. 
Esta es su sintaxis:

```makefile
objetivos: pre-requisitos | pre-requisitos solo-orden
```











\end{document}